## 一、垃圾回收算法

- Mark-Sweep 标记清除：位置不连续，产生碎片
- Copying 拷贝算法：没有碎片、浪费空间、占用空间大
- Mark-Compack 标记压缩：没有碎片、效率偏低

## 二、什么时候会触发垃圾回收

​		系统运行时创建的对象都是优先分配在新生代里的，当新生代里的对象越来越多，都快满了的时候，便会触发垃圾回收，把新生代中没有被引用的对象回收掉，释放内存空间。当然老年代的空间不足时也会触发Full GC来释放空间。系统在进行垃圾回收的期间，应用程序属于暂停状态，否则无法准确获取垃圾对象。

**垃圾回收分为：**

- Minor GC
- Full GC

## 三、新生代垃圾回收

### 3.1 垃圾回收算法

- Copying 拷贝算法

  系统运行期间，不停的向新生代中分配对象，但是这些对象很大一部分很快就会使用结束，变成垃圾对象，如果采用标记清除算法，GC过后的新生代中将产生很多不连续的的对象位置，产生碎片，对于新对象的分配的很不友好，造成空间的浪费。如果对GC后的新生代空间进行压缩，则有增加了压缩所需的时间，由于Minor GC的频率很高，这样对于业务系统的所产生的延时就不可忽视了。

  基于新生代的内存模型来看，Copying拷贝算法较为适合，Eden区快满时，GC线程将有引用的对象一次性拷贝到Survivor区(S0)，然后将Eden区全部清空。待Eden区快满时，GC线程将Eden区和S0区中有引用的对象一次性拷贝到S1区，然后清空S0和Eden区，如此反复。

### 3.2 新生代中的对象什么情况下进入老年代

- 年龄

### 3.3 动态对象年龄判断



3. 
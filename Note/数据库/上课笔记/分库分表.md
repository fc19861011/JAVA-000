随着数据量的增大，读写并发的增加，系统可用性要求的提升，单机MySQL面临：

1、容量有限，难以扩容

2、读写压力，QPS过大，特别是分析类需求会影响到业务事务

3、可用性不足，宕机问题

技术演进：

读写压力  -> 多机集群 -> 主从赋值

高可用性 -> 故障转疑-> MHA/MGR/Orchestrator

容量问题->数据库拆分->分库分表（垂直（业务拆分）/水平（分库分表））

（以上严谨也带来了问题）一致性问题 -> 分布式事务 -> XA/柔性事务

刚性事务：遵循ACID原则，强一致性

柔性事务：遵循BASE理论，最终一致性；与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。

淘宝：

2003:php -> 三丰（技术） 睡机房重启 -> 请ibm辅导改java，先把用户模块独立出来，将用户服务打包成jar，让其他系统引入 - > 服务化，提供接口

数据异构化集群

2000年，MySQL3.23.15版本引入了复制

2002年，MySQL4.0.2版本分离IO和SQL线程，引入了relay log

2010年，MySQL5.5版本引入半同步复制

2016年，MySQL在5.7.17中引入InnoDB Group Replication

主从复制原理：

binlog类型

- ROW
- Statement
- Mixed

异步复制：传统主从复制--2000年，MySQL 3.23.15版本引入了Replication

异步复制：网络或机器故障，会造成数据不一致

半同步复制：需要启用插件（Primary-Secondary Replication）(传统主从复制)

半同步复制：保证source和Replica最终一致性（待有一个从库回复已接收到，便提交）

组复制：MySQL Group Replication(MGR)

组复制：基于分布式Paxos协议实现组复制，保证数据一致性（要装插件）

查看插件：show plugins;

冷备和热备备份的是机器，不是数据

备份机器是否在干活，冷热代表的是机器是否在工作

> 早期atviveMQ只支持冷备，原理select *  from table for update，不释放锁，谁写抢到，谁就开始工作，挂了就就释放锁。然后存活的开始争用

数据的备份就是增量备份和全量备份



主从复制的局限性：

1、主从延迟问题（数据分片可以缓解这个问题）

2、应用侧需要配合读写分离框架

3、不解决高可用问题

tddl ->DRDS

京东CDS 白条用的sharding-jdbc

CDS的功能会逐步揉到sharding

JSF就是dubbo （dubbo上加了些UI）



人的反应时间>100ms

极致数据同步，尽量再一个事务（在主库上做）



高可用(HA):

定义:

SLA：一般都是99.95%

SLA计算：主动停机维护时间去掉，只算计划外的事故，故障

99.95% = 3+log(10)5

99.9 %: -log10(1-0.999)   3 

99.99%: -log10(1-0.9999) 4 

99.95: -log10(1-0.9995)  3.301 

RTO 

数据中心之间要求超过 为什么超过800公里 



对数？ log



DMZ



垂直拆分，微服务的内容



水平拆分，容量的内容



面试技巧：

面试官问的内容比较抽象，需要跟他互动引导出来他的意图，要么曹自己会的方向引导





分库分表涉及的数据迁移，都会碰到很多大问题，关注下，这方面知识点

再过5年分布式数据库成熟了，分库分表就没那么重要了

提高技术视野，技术能力去干更高级的事情



证券比较注重RDMA\PM

tfs fastdfs glut 

